{"componentChunkName":"component---src-templates-markdown-js","path":"/blueprints/blueprint/docs/adr/0004-argocd-apps-of-apps-structure.md","result":{"data":{"site":{"siteMetadata":{"title":"Operate First"}},"markdownRemark":{"id":"07fcc728-fa5f-55ea-a016-f26e860b3edb","html":"<h1>ArgoCD Apps of Apps Structure</h1>\n<h2>Context and Problem Statement</h2>\n<p>ArgoCD <code class=\"language-text\">Applications</code> manifests are a <a href=\"https://argoproj.github.io/argo-cd/operator-manual/declarative-setup/#applications\">declarative way to manage</a> ArgoCD <code class=\"language-text\">Applications</code> in git. Often times these are manifests that are stored alongside ArgoCD deployment manifests.</p>\n<p>This has been fine in the past since we controlled the deployment of ArgoCD and had merge access to the repo where the applications were stored. So if we wanted to onboard a new app, we make a PR with the application manifest and someone on our team would merge it.</p>\n<p>But there can be a situation where another team, like cluster-admins or infra, store the ArgoCD deployments in their own repo. </p>\n<p>If we applied our current practice, we’d store our app manifests in this external repo. The problem is that we may not have merge access to this repo, and it wouldn’t really make much sense for people who manage the infrastructure to also handle PR’s that don’t pertain directly to cluster management.</p>\n<h2>Considered Options</h2>\n<ol class=\"pf-c-list\">\n<li>Just have All ArgoCD Manifests in one repo and give Operate-First team members access to infra repo so they can review and merge ArgoCD <code class=\"language-text\">Applications</code>. </li>\n<li>Have separate teams handle Applications for their Projects in their own Repos, in this way tracking Applications is not a concern for Infra/Operate-first, but rather the individual team belonging to an ArgoCD project</li>\n<li>Have a separate Repo that Operate-First manages, and have a an ArgoCD App of Apps that manages this repo. </li>\n</ol>\n<h2>Decision Outcome</h2>\n<p>Chosen Option <code class=\"language-text\">(3)</code>. Problems with <code class=\"language-text\">(1)</code> have been outlined above. The issues with <code class=\"language-text\">(3)</code> is that there is no way to effectively enforce teams to ensure their App Projects belong to their team’s project (this is further described below). </p>\n<p>The Proposed Solution is captured by this diagram: </p>\n<p><img src=\"https://user-images.githubusercontent.com/10904967/99705533-d8aac380-2a67-11eb-88e9-b63582271994.png\" alt=\"image\"></p>\n<p>The idea here is that all our operate-first/team-1/team-2/…/team-n ArgoCD <code class=\"language-text\">Applications</code> would go in the <code class=\"language-text\">opf-argocd-apps</code> repo. Then we’d have an App of Apps i.e. the <code class=\"language-text\">OPF Parent App</code> that manages all these apps. This way we can add new applications declaratively to ArgoCD without having to make PR’s to the <code class=\"language-text\">Infra Repo</code> (e.g. <code class=\"language-text\">moc-cnv-sandbox</code>). Operate-first admins would manage the <code class=\"language-text\">opf-argocd-app</code> repo. Any other ArgoCD <code class=\"language-text\">Applications</code> that manage cluster resources like <code class=\"language-text\">clusterrolebindings</code> or operator <code class=\"language-text\">subscriptions</code> etc. can remain in the infra repo since that’s a concern for cluster admins. We would direct any <em>user</em> that wants to use ArgoCD to manage their apps to add their ArgoCD <code class=\"language-text\">Applications</code> to the <code class=\"language-text\">opf-argocd-apps</code> repo. </p>\n<h3>Positive Consequences</h3>\n<ul class=\"pf-c-list\">\n<li>Infrastructure/cluster-admins are not bombarded with PR’s for ArgoCD App onboarding </li>\n<li>OperateFirst maintainers can handle the PR’s unhindered </li>\n<li>The “OPF-ArgoCD-Apps” repo can be leveraged by CRC/Quicklab/Other OCP Clusters to quickly setup ArgoCD ODH/Thoth/etc. Applications. </li>\n</ul>\n<h3>Negative Consequences</h3>\n<p>Biggest concern here is that there is no way to automatically enforce that Applications in <code class=\"language-text\">opf-argocd-apps</code> repo <em>belong</em> to the <code class=\"language-text\">Operate First</code> ArgoCD project (see diagaram). <em>Why is this a problem?</em> Because we use ArgoCD projects to restrict what types of resources applications <em>in that project can deploy</em>. For example ArgoCD apps in the <code class=\"language-text\">Infra Apps</code> project in the diagram can deploy <code class=\"language-text\">clusterrolebinding</code>, <code class=\"language-text\">operators</code>, etc. So while <code class=\"language-text\">OPF Parent App</code> cannot deploy <code class=\"language-text\">clusterrolebindings</code> because it belongs to the <code class=\"language-text\">Operate First</code> ArgoCD project, it could deploy another ArgoCD application that belongs to <code class=\"language-text\">Infra apps</code> and <em>that ArgoCD app</em> could deploy clusterrolebindings. </p>\n<p>You can read more about this <a href=\"https://github.com/argoproj/argo-cd/issues/3045\">issue here</a>. The individual there used admission hooks to get around this but I don’t think we want to go there just yet. My suggestion is we begin by enforcing this at the PR level, and transition to maybe catching this in CI until there’s a proper solution upstream. </p>","frontmatter":{"title":"","description":null}}},"pageContext":{"id":"07fcc728-fa5f-55ea-a016-f26e860b3edb"}},"staticQueryHashes":["117426894","3000541721"]}